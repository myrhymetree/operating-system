![image](https://github.com/myrhymetree/operating-system/assets/94158097/f79b7a8a-72f7-47a1-946a-6bcadc6dd361)# 7.가상메모리

## 7.1 가상 메모리의 개념

1. 가상메모리(virtual memory)
    
    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/50618b75-faa7-49f2-bb4e-dcbab9206004" width="30%" height="30%"/>
    
- 메모리 크기보다 더 큰 기억공간이 필요한 프로세스는 실행불가
    
    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/3ae960c6-855a-4d1b-821f-8d470d5e8a5e" width="30%" height="30%"/>

    
- 컴퓨터 시스템의 메모리 크기보다 더 큰 기억공간이 필요한 프로세스를 실행할 수 있게 하는 방법
- 핵심은 실행 중인 프로세스에 의해 참조되는 주소(가상주소)를 메모리에서 사용하는 주소(실주소)와 분리하는 것
- 현재 필요한 일부만 메모리에 적재

<img src="https://github.com/myrhymetree/operating-system/assets/94158097/7f570588-ccb7-4d4c-be76-08ef69ade0ce" width="50%" height="50%"/>

    
1. 사상(mapping)
- 가상주소를 실주소로 변환하는 과정
1. 동적 주소 변환(Dynamic Address Translation, DAT)
    - 주소 변환이 가상주소 내의 각 항목별로, 즉 바이트나 워드 단위로 이루어지면 변환에 필요한 정보량이 너무 많아짐
    -> 프로세스가 요구하는 메모리 공간보다 더 큰 기억장소를 필요로 함.
    -> 사상정보의 양을 줄여야 함
    - 프로세스가 실행되는 동안 가상주소를 실주소로 바꾸는 절차
    - 주소 변환 사상표를 이용
2. 인위적 연속성
    - 가상주소 공간에서 연속인 주소가 실주소공간에서도 연속일 필요는 없음

        <img src="https://github.com/myrhymetree/operating-system/assets/94158097/47102a0c-cb21-40f2-b00f-053a558545c0" width="50%" height="50%"/>
        

## 7.2 블록 단위 주소 변환

1. 항목별(바이트나 워드 단위) 변환의 문제점
    - 변환에 필요한 정보량이 많아 비효율적임
2. 주소 변환 사상표
    - 동적 주소변환을 위한 정보를 가진 표

        <img src="https://github.com/myrhymetree/operating-system/assets/94158097/c51d8d11-0a07-4b59-b9fb-d5cc9b459b08" width="80%" height="80%"/>
        
    - 주소 변환이 필요한 바이트나 워드 단위로 이뤄지면 변환에 필요한 정보량이 너무 많아 비효율적임
3. 블록 사상 시스템
    - 정보를 블록 단위로 분류하여 각 블록이 메모리의 어디에 위치하는지만을 관리
    - 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리
    - 가상주소 ｖ= (ｂ, ｄ): b는 블록 번호, d는 블록의 시작점으로부터의 변위
  
      <img src="https://github.com/myrhymetree/operating-system/assets/94158097/981f1fd7-6cb6-4d2b-8fab-d3e38e8f293f" width="80%" height="80%"/>

        
    - 블록의 크기는 적절히 정해야 함
        - 크기가 커질수록
            - 사상표 크기 감소
            - 블록 전송시간 증가, 동시에 적재할 프로세스 수 감소
        - 크기가 작아질수록
            - 블록 전송시간 감소, 동시에 적재할 프로세스 수 증가
            - 사상표 크기 증가
4. 블록 구성 방식

    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/d4c952f5-5737-4c97-ba83-ab8ff4f4e50a" width="50%" height="50%"/>
    
    - 페이지 : 블록의 크기가 동일
    - 세그먼트 : 블록의 크기가 다름

## 7.2.1 페이징 기법

1. 페이징 기법
    - 가상 메모리를 페이지 단위로 나누어 관리하는 기법
    - 메모리 영역도 페이지와 동일한 크기의 페이지 프레임으로 나눔
        - 페이지 프레임 : 페이지를 담을 수 있는 틀
  
        <img src="https://github.com/myrhymetree/operating-system/assets/94158097/5978792a-3395-46c4-bfe0-333861e9da86" width="80%" height="80%"/>

        
2. 페이지 프레임
    - 가상 메모리의 동일한 고정된 크기로 분할된 메모리 영역의 블록
    - 가상 메모리 상의 페이지를 담을 수 있도록 실제 메모리에 틀(frame)을 만들어 둔 것
3. 페이지 사상표

    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/fcd82cfb-4fd5-42fe-9f8a-532a0552d372" width="80%" height="80%"/>
    
    - 프로세스가 사용하는 가상주소를 메모리에 적재된 후에도 바로 찾을 수 있도록 실주소로 동적 변환을 할 수 있게 함.
    - 페이지 번호에 대한 페이지 프레임 번호 저장
  
        <img src="https://github.com/myrhymetree/operating-system/assets/94158097/e27d8970-e732-458b-8efd-b2c9a5223a1f" width="50%" height="50%"/>
      
        
    - 가상주소의 페이지 번호별 저장 정보 : 실주소의 페이지 프레임 번호, 현재 메모리에 존재하는지의 여부 비트값, 보조기억장치의 주소
    
5. 동적 주소 변환
    - 직접 사상 : 페이지 사상표를 직접 이용하여 동적 주소 변환
    
    ![image](https://github.com/myrhymetree/operating-system/assets/94158097/22d11389-8ad2-4bee-a398-b9999e35d006)
    
    - 연관 사상 : 페이지 변환 정보를 연관 기억장치에 저장한 연관 사상표를 이용하여 동적 주소 변환
        
        ![image](https://github.com/myrhymetree/operating-system/assets/94158097/0d8086b8-57b1-4502-b6a0-035e4a3d384c)
        
    - 연관 기억장치 : 저장된 값을 이용하여 데이터를 엑세스하는 고속 메모리 장치
    
    ![image](https://github.com/myrhymetree/operating-system/assets/94158097/02a5f1bf-3617-4599-9807-0a07fa3e3ea2)
    
    - 연관 / 직접 사상 : 연관 사상표에는 가장 최근에 참조된 페이지 항목만 보관하고 나머지는 페이지 사상표에 수록하여, 연관 사상표에 없을 때는 직접 사상 기법으로 변환
6. 페이징 기법의 특징
    - 논리적 의미와 무관한 동일 크기의 페이지로 나눔
    - 메모리 보호는 페이지 단위로 이루어짐
    - 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있음

## 7.2.2 세그먼테이션 기법

1. 세그먼테이션 기법
   
    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/17948670-fe23-4b64-a1ce-999701b4124f" width="50%" height="50%"/>

    - 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법
        - 세그먼트 : 논리적 의미에 부합하는 다양한 크기의 블록
    - 세그먼트 사상표를 이용하여 동적 주소변환
    - 메모리 적재를 위해서는 최초 적합(first-fit), 최적 적합(best-fit) 등의 방법 이용
2. 세그먼트 사상표

    <img src="https://github.com/myrhymetree/operating-system/assets/94158097/85f2d99d-30e4-4d90-ac3e-1a12f7d5c025" width="50%" height="50%"/>
    
    - 페이지 사상표와 유사
        - 세그먼트 번호에 대한 실주소에서의 시작 위치 저장
        - 세그먼트 길이는 오버플로 확인용
        - 가상 주소의 세그먼트 번호별 저장 정보 : 실주소의 시작위치, 현재 메모리에 존재하는지의 여부 비트값, 보조기억장치의 주소, 세그먼트의 길이
        - 세그먼트 존재 비트 : 해당 세그먼트가 현재 메모리에 존재하는지 여부를 나타내는 비트값
    - 동적 주소변환
        
        ![image](https://github.com/myrhymetree/operating-system/assets/94158097/0cca70a5-e1fe-4f71-a7c5-42de4d5e6a5f)
        

## 7.2.3 페이징/세그먼테이션 혼용기법

![image](https://github.com/myrhymetree/operating-system/assets/94158097/aa75c31c-02e8-4d0b-9271-fab0b1655983)

![image](https://github.com/myrhymetree/operating-system/assets/94158097/a2af0a69-5a03-442f-93c4-23c5d7737850)

1. 페이징/세그먼테이션 혼용기법
    - 세그먼테이션 기법의 논리적 장점과 페이징 기법의 메모리 관리 측면의 장점을 활용
    - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할
    - 메모리도 페이지 프레임으로 분할하여 하나의 페이지만 페이지 프레임에 적재하는 방식
    - 세그먼트 사상표에 저장되는 주소는 실주소가 아닌 각 세그먼트에 대한 페이지 사상표의 시작 주소(그림에서 180)
    - 동적 주소변환
        
![image](https://github.com/myrhymetree/operating-system/assets/94158097/0bb090f7-9b98-4bbb-a17e-28a1388b0ae6)
        

# 7.3 페이지 호출기법

1. 메모리 호출기법
    - 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가를 결정하는 기법
    - 페이징 기법에서 호출기법 종류
        - 요구 페이지 호출 기법
  
            <img src="https://github.com/myrhymetree/operating-system/assets/94158097/5493fd51-f9e3-4cf2-846f-1af3ca01a54b" width="50%" height="50%"/>
            
        - 예상 페이지 호출 기법
     
            <img src="https://github.com/myrhymetree/operating-system/assets/94158097/ff2d117a-659d-40d0-8495-626338f8a8ba" width="50%" height="50%"/>

            
2. 요구 페이지 호출기법(demand page fetch strategy)
    - 페이지가 요구될 때 해당 페이지를 메모리로 옮김
    - 페이지 결정에 대한 오버헤드가 최소화됨
    - 적재된 페이지는 실제로 참조됨
    - 프로세스 시작 지점에는 연속적으로 페이지 부재 발생
3. 예상 페이지 호출기법
    - 필요한 페이지를 예상하여 미리 페이지를 메모리에 옮김
    - 프로세스 시작 지점에 적용하면 성능이 개선됨
    - 예상이 옳았다면 실제로 필요한 시점이 되었을 때 프로세스 실행이 단절되지 않음
    - 예상이 잘못된 경우 시간과 메모리 공간 낭비

## 7.4 페이지 교체기법

1. 페이징 기법
    - 모든 페이지 프레임이 사용되고 있을 때 새로 적재되어야 할 페이지를 위해 적절한 교체 대상을 결정
        
        ![image](https://github.com/myrhymetree/operating-system/assets/94158097/4ac6ea1f-c7cf-4d6a-9eab-35dc20e3d119)
        
2. 최적화 원칙(principle of optimality)
    - 최적의 성과를 얻기 위해 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택
    - 이론적으로 최적이나 미래를 예측할 수 없으므로 실제로 실현은 불가능
3. 선택을 위한 기본 정책
    - 대체로 좋은 결론은 내리면서 선택을 위한 시간 및 공간 오버헤드가 가장 적은 방법
4. 페이지 고정(교체 제외 페이지)
    - 효율적인 동작을 위해 어떤 페이지들은 교체가 일어나지 않도록 고정
    - 페이징을 위한 슈퍼바이저(커널) 코드 영역
    - 커널에 속하지 못한 보조기억장치 드라이버 영역
    - 시간을 맞춰 동작해야 하는 코드 영역
    - DMA 등에 의해 입출력장치로부터 직접 데이터가 교환되어야 하는 데이터 버퍼 영역 등

```
휴리스틱(Heuristics)이란,
문제를 해결하거나 불확실한 사항에 대해 판단을 내릴 필요가 있지만, 명확한 실마리가 없을 경우에 사용하는 편의적 발견적인 방법입니다. 다른 말로 표현하면 쉬운방법, 간편법, 발견법, 어림셈(어림짐작)이라고 말할 수 있습니다.

```

## 7.4.1 FIFO 페이지 교체

1. FIFO(First=In-First-Out) 페이지 교체 기법
    - 메모리 내에 가장 오래 있었던 페이지를 교체
    - 각 페이지가 메모리에 적재될 때마다 그때의 시간을 기억
    - FIFO 큐로 구현
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/dd35f666-6b07-414e-b3df-11afb4f5dfb5/Untitled.png)
        
2. 단점
    - 가장 많이 사용하는 페이지를 교체시킬 가능성 있음
    - Belady의 이상현상(anomaly): 프로세스에 더 많은 수의 페이지 프레임을 할당할 경우 오히려 페이지 부재가 더 많이 발생할 수 있는 경우
     <br/>
    *Belady의 이상현상*
        
        ![Belady의 이상현상.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/b36a8227-fdbe-4d01-b70e-7cfc272daef2/Belady%EC%9D%98_%EC%9D%B4%EC%83%81%ED%98%84%EC%83%81.png)
        

## 7.4.2 LRU 페이지 교체

1. LUR(Least Recently Used) 페이지 교체기법
    - 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체
    - 최근의 상황이 가까운 미래에 대한 좋은 척도라는 국부성 휴리스틱에 의존하는 것
    - 구현 : 참조시각 또는 리스트 이용
2. 국부성(locality)
    - 최근의 상황이 가까운 미래에 대한 좋은 척도
    - 프로세스는 기억장치 내의 정보를 어느 한순간에 특정 부분을 집중적으로 참조한다는 것
    - 시간 국부성과 공간 국부성
    - 시간 국부성 : 오후 3시에 날씨가 맑으면 오후 3시 30분에도 날씨가 맑을 가능성이 높다는 것
    - 공간 국부성 : 서울에 날씨가 맑다면 인천도 날씨가 맑을 가능성이 높다는 것
3. 참조시간을 이용한 LRU 구현
    - 각 페이지가 참조될 때마다 그때의 시간을 테이블에 기록
    - 페이지를 엑세스하면 해당 페이지 번호를 리스트의 선두에 옮김
    - 교체가 필요한 경우 리스트의 끝에 있는 페이지(참조시각이 가장 오래됨)가 교체 대상으로 선택
    
    ![*참조시간을 이용한 LRU 페이지 교체기법 구현*](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/29b9f2c4-aefa-40c7-bd33-c6c4d13226fa/Untitled.png)
    
    *참조시간을 이용한 LRU 페이지 교체기법 구현*
    
4. 리스트를 이용한 LRU 구현
    - 메모리에 적재된 페이지 번호를 저장하는 리스트를 이용
    - 페이지를 엑세스하면 해당 페이지 번호를 리스트의 선두에 옮김
    - 교체가 필요한 경우 리스트의 끝에 있는 페이지가 교체 대상으로 선택
     <br />
    *리스트를 이용한 LRU 페이지 교체기법 구현*
        
        ![LRU페이지교체.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/c6aaa7da-f483-4428-9c8f-27a4eecbaaee/LRU%ED%8E%98%EC%9D%B4%EC%A7%80%EA%B5%90%EC%B2%B4.png)
        
5. 장점
    - Belady의 이상현상이 발생하지 않음
    - 많은 경우 최적화 원칙에 근사한 선택 가능
6. 단점
    - 경험적 판단이 맞지 않는 상황이 존재(여러 페이지로 구성되는 커다란 루프)
    - 국부성이 맞지 않는 상황도 존재
    - 막대한 오버헤드, 별로 이용되지 않음

## 7.4.3 LFU 페이지 교체

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/10663bad-0d97-4113-93fe-f5b16af7bbad/Untitled.png)

1. LFU(Least Frequetly Used)페이지 교체 기법
    - 참조된 횟수가 가장 적은 페이지가 교체
    - 구현 : 참조횟수 이용
2. 단점
    - 가장 드물게 이용되는 페이지가 가장 최근에 메모리로 옮겨진 페이지일 가능성 있음
    - 초기에 매우 많이 사용된 후 더 이상 사용되지 않는 페이지는 불필요하게 메모리를 점유할 가능성 있음
    - 오버헤드가 큼

## 7.4.4 NUR 페이지 교체

1. NUR(Not Used Recently) 페이지 교체기법
    - 적은 오버헤드로 적절한 성능, 실제로 자주 사용되는 기법
    - 참조 여부와 수정 여부에 따라 페이지들을 네 그룹으로 구분
    <br />
    |그룹|r|m|비고|
    |---|---|---|---|
    |1|0|0|참조 O, 수정 X|
    |2|0|1|참조 X, 수정 O|
    |3|1|0|참조 O, 수정 X|
    |4|1|1|참조 O, 수정 O|
- 페이지 교체가 필요한 경우에는 그룹 1, 그룹 2, 그룹 3, 그룹 4의 순으로 비어 있지 않는 그룹에서 교체대상을 선택
- 그룹 내에서 선택은 무작위

## 7.4.5 2차 기회 페이지 교체

1. 2차 기회 페이지 교체기법
    - 참조 비트를 활용
    - 참조 비트가 0이면서 메모리 내에 가장 오래 있었던 페이지를 선택하여 교체
    - 구현 FIFO 큐와 참조 비트 이용
        - 각 페이지가 메모리에 적재될 때는 참조 비트 0
        - 적재된 상태에서 추가로 참조되면 참조 비트 1
        - 페이지 교체가 필요한 경우에는 FIFO 큐의 선두 항목을 꺼내 참조비트를 조사하여 '0'이면 그 프레임을 교체 대상으로 선택, '1'이면 이를 '0'으로 지우고 FIFO 큐의 뒤에 넣음
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/0bd0e929-56f2-4747-ad5d-083e0dd03207/Untitled.png)
        
    - 참조할 페이지가 메모리에 없는 경우
        - 빈 페이지 프레임이 있으면
            - 페이지 적재, 큐에 추가, 참조 비트는 0으로 설정
        - 빈 페이지 프레임이 없으면
            1. 큐의 선두 항목을 꺼내 참조 비트 조사
            2. 1이면 0으로 바꿔 큐의 뒤에 추가 후 1단계로 이동
            3. 0이면 교체 대상으로 선택하여 교체
    - 참조할 페이지가 메모리에 있는 경우
        - 큐 위치 변화 없이 참조 비트만 1로 설정
        - 큐를 이용한 구현
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/e8d63557-ddaa-4a4c-ac54-90fcb6e43edc/Untitled.png)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/d6e63704-e0c6-4375-899f-f54ad1af3f25/Untitled.png)
        

## 7.4.6 클럭 페이지 교체

1. 클럭 페이지 교체(변형된 원형 큐를 이용한 구현)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/b42ea595-93dc-4cb2-a3bd-4f01bf439f98/Untitled.png)
    
    - 2차 기회 알고리즘에서 선형 큐 대신 원형 큐를 사용
    - 포인터가 시계바늘이 돌아가는 것처럼 원형 큐를 돌며 교체 대상 결정
    - 포인터는 마지막에 추가된 페이지의 다음 위치를 가리킴
        - 빈 페이지 프레임이 있는 경우 : 빈칸
        - 페이지 프레임이 꽉 찬 경우 : 큐의 선두
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/5898f8ef-bd96-4c41-a954-e57f9ca0bdb5/Untitled.png)
    

## 7.4.7 프로세스별 페이지 집합 관리

- 프로세스마다 사용할 수 있는 페이지 프레임의 개수만큼 메모리에 유지되는 페이지 집합
- 집합의 크기가 작을 수록 시스템 처리량 증대
    - 각 프로세스별 페이지 부재는 자주 발생하여 성능 저하
- 집합의 크기가 클수록 프로세스별 페이지 부재는 감소
    - 메모리에 적재될 수 있는 프로세스 수는 줄어듦
- 각 프로세스가 사용할 수 있는 페이지 프레임 개수 관리
    - 워킹 세트 알고리즘, PFF 알고리즘
1. 워킹세트(working set) 알고리즘
    - 페이지 부재 비율을 감소시키기 위하여 Denning이 제안
    - 워킹세트 : 하나의 프로세스가 자주 참조하는 페이지의 집합
    - 프로세스의 워킹세트 W(t,δ)
        - 시각 t에 t를 포함한 직전 δ시간 동안 참조한 페이지의 집합
        - 시간 t에서 한 프로세스의 워킹세트 W(t, w)는 t-w로부터 t까지의 프로세스 시간 간격 동안 참조된 페이지의 집합
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/2bbf25ed-4605-4aa0-bc9f-b76fcd9c6644/Untitled.png)
        
    - 워킹세트 알고리즘
        - 프로세스가 수행됢에 따라 그 프로세스의 워킹 세트는 변할 수 있으며 워킹 세트의 크기도 달라질 수 있음
        - 워킹 세트 알고리즘의 원칙
            - 실행중인 프로그램의 워킹세트를 메모리에 유지시키는 것
        - 워킹 세트를 메모리에 유지하지 않으면 쓰레싱 유발 가능
            - 쓰레싱(thrashing) : 페이지 부재가 비정상적으로 많이 발생하여 프로그램의 처리보다 페이지 교체에 너무 많은 시간을 소비함으로써 시스템의 처리량이 급격히 저하되는 현상
        - 프로세스마다 워킹 세트 크기에 맞게 페이지 프레임 개수 조절
        - 충분한 여분의 페이지 프레임이 존재
            - 실행 프로세스 수 늘림
        - 실행 중인 프로세스들의 워킹 세트 크기의 합이 총 페이지 프레임 수를 넘어섬
            - 우선순위가 낮은 프로세스를 일시 중지
        - 문제점
            - 과거를 통해 미래를 예측하는 것이 정확하지 않음
            - 워킹 세트를 정확히 알아내고 계속 업데이트하는 것이 현실적으로 어려움
            - 워킹세트 윈도 크기 δ의 최적값을 알기 어려우며 이 역시 변화할 수 있음
2. PFF(Page Fault Frequency) 알고리즘
    - 페이지 부재 빈도(PFF)를 이용하여 프로세스 별 페이지 집합의 크기를 변화시키는 기법
    - PFF(Page Fault Frequency)
        - 얼마나 자주 페이지 교체가 발생하는지를 나타내는 척도
        - 페이지 부재가 발생하면 직전 페이지 부재 이후로 경과된 시간의 역수
    - 상주 페이지 세트 : 프로세스가 페이지 부재 때문에 멈추게 되는 빈도에 기초한 페이지 세트
    - PFF 알고리즘
        - PFF의 상한과 하한을 정해 둠
            - PFF가 상한보다 높으면 페이지 프레임 개수를 1증가
            - PFF가 하한보다 낮으면 그 사이에 참조되지 않았던 페이지를 모두 제거
        - 페이지 부재 빈도가 상한보다 높으면 들어오려는 페이지는 그 프로세스의 상주 페이지 세트에 추가하고, 페이지 부재 빈도가 하한보다 낮으면 그 사이에 호출되지 않았던 페이지는 모두 제거
        - 장점 : 프로세스별 페이지 집합이 워킹 세트 알고리즘처럼 자주 바뀌지 않음

## 참고

연관/직접 사상
[https://velog.io/@choi-yh/OS-가상-메모리-관리](https://velog.io/@choi-yh/OS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC)
