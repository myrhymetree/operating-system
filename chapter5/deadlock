# 5. 교착상태

## 5.1 교착상태의 개념

1. 교착상태(deadlock)
    - 두 개 이상의 프로세스가 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 결과적으로 아무도 완료되지 못하는 상태
2. 교착상태와 기아상태의 차이
    - 교착상태 : 관련된 모든 프로세스가 무한히 대기상태인 것
    - 기아상태 : 관련된 프로세스의 일부가 지속적으로 대기상태인 것

## 5.2 교착상태의 특성

### 5.2.1 교착상태의 필요조건

1. 상호배제 조건
    - 프로세스들이 자원에 대한 배타적인 통제권을 요구하는 조건
    - 필요로 하는 자원을 다른 프로세스가 점유하고 있으면 반드시 대기하여야 함
2. 점유 대기 조건
    - 프로세스가 이미 다른 자원을 할당받아 배타적으로 점유하고 있는 상황에서 다른 프로세스가 점유하고 있는 자원이 해제되기를 기다리는 상황
3. 비선점 조건
    - 프로세스에 할당된 자원은 그 프로세스가 사용을 마치고 스스로 반환되기 전에 제거되지 않음
4. 환형 대기 조건
    - 프로세스의 자원 점유 및 점유된 자원의 요구 관계가 환형을 이루며 대기하는 조건

## 5.2.2 자원할당 그래프

1. 자원할당 그래프 G=(V,E)
    - V=P∪R: 정점의 집합, P={p₁, p₂, … pₙ}는 n개의 프로세스 정점, R={r₁, r₂, … rₘ}은 m개의 자원 정점
    - E=Q∪S : 방향 있는 간선의 집합. Q={(pᵢ, rⱼ)}: pᵢ ∈ P, rⱼ ∈ R}는 프로세스 pᵢ가 자원 rⱼ를 요구하는 요구간선, S={(rⱼ, pᵢ):  rⱼ ∈ R,: pᵢ ∈ P}는 자원 rⱼ가 프로세스 pᵢ에 할당되어 있는 할당간선
2. 자원할당 그래프와 교착상태의 관계
    - 자원할당 그래프가 사이클을 포함하지 않으면 교착상태는 발생하지 않음.
    - 자원할당  그래프가 사이클을 포함하는 경우에는 교착상태가 될수도 있고 안될 수도 있음
        
        (프로세스의 자원 선점이 해제 되는 경우는 사이클이 풀리기 때문)
        

## 5.3 교착상태 처리

1. 교착상태 방지
    - 교착상태의 네 가지 필요조건 중 하나라도 발생할 수 없도록 막는 방법
2. 교착상태 회피
    - 프로세스에 필요한 자원의 최대량에 대한 정보를 활용하여 교착상태가 발생하지 않도록 함
3. 교착상태 탐지 및 복구
    - 교착상태가 발생하면 이에 따른 적절한 조치를 취하여 정상 상태로 복구하는 방법

### 5.3.1 방지

1. 상호배제 조건의 제거
    - 공유할 수 있는 자원은 상호배제를 할 필요가 없으므로 교착상태를 유발하지 않음
    - 공유할 수 없는 자원은 반드시 상호배제를 따라야만 하므로 사실상 상호배제 조건을 제거하여 교착상태를 방지하는 것은 불가능
2. 점유 대기 조건의 제거
    - 프로세스가 자원을 요청할 때 그 프로세스는 어떠한 자원도 할당받지 않은 상태여야 함.
    - 방법 1 : 프로세스가 수행을 시작하기 전에 필요한 모든 자원을 한꺼번에 요구하여 할당 받는 것
    - 방법 2 : 자원을 부분적으로 요청하여 할당받을 수 있도록 하되, 자원을 추가로 요청할 때에는 이전에 가지고 있던 자원을 반드시 모두 해제한 후 할당 받는 것.
    - 문제점 : 방법 1은 자원 이용률이 매우 낮아질 수 있고, 방법 2는 기아상태가 발생할 수 있음
3. 비선점 조건의 제거
    - 방법 1 : 자원을 점유하고 있는 프로세스가 즉시 사용할 수 없는 상황의 다라른 자원을 요청하는 경우 점유하고 있던 자원을 해제하는 것
    - 방법 2 : 프로세스가 가용하지 않은 자원을 요청하면 그 자원이 할당된 프로세스가 다른 자원을 기다리며 대기중인지 조사하고, 만일 그렇다면 대기상태인 프로세스로부터 자원을 선점하여 요청한 프로세스에게 항당함. 다른 경우라면 요청한 프로세스는 반드시 대기해야 함
    - 상태를 쉽게 보관하고 복구할 수 있는 자원이 아니라면 적용이 불가능함(내부자원, 메모리 같은 경우 적용 가능)
4. 환형 대기 조건의 제거
    - 모든 자원의 유형에 일련번호를 지정하기 위해 함수 f를 정의
    - 함수 f는 rᵢ ≠ rⱼ이면 f(rᵢ) ≠ f(rⱼ)를 만족(단사함수)
    - 방법 1 : 프로세스는 자원을 일련번호 기준으로 항상 오름차순으로 요청하도록 하는 것(자원  rᵢ를 점유하고 있는 경우 반드시 f(rᵢ) ≤ f(rⱼ)인 경우만 rⱼ를 요청할 수 있음)
    - 방법 2 : 프로세스 자원 rⱼ를 요구할 때마다  f(rⱼ) ≤ f(rᵢ)인 자원 rᵢ는 모두 해제하도록 하는것
    - 함수 f의 정의는 전체 시스템의 성능에 큰 영향을 미치므로 실제로 사용되는 순서를 감안하여 정의하여야 함

### 5.3.2 회피

1. 회피
    - 프로세스의 자원 사용에 대한 사전 정보를 활용하여 교착상태가 발생하지 않는 상태에 머물도록 하는 방법
2. 안전상태
    - 교착상태를 회피하면서 각 프로세스에게 그들의 최대 요구량까지 빠짐없이 자원을 할당할 수 있는 상태
    - 교착상태가 아님
3. 안전 순서열
    - 순서있는 프로세스의 집합 <p₁, p₂, …, pₙ>
    - 각 pᵢ는 pᵢ가 추가로 요구할 수 있는 자원 소요량이 현재 가용 상태이거나 혹은 현재 가용인 자원에 j < i인 pⱼ에 할당된 자원까지 포함하여 할당이 가능한 경우
4. 불안전상태
    - 안전 순서열이 존재하지 않는 경우
    - 할당과정에 따라 교착상태가 될 수도 있음
5. 각 유형의 단위자원이 여러 개일 경우
    - 은행원 알고리즘 이용
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/6577d1bc-ee4f-47c1-87ba-f4b2f5acd95e/Untitled.png)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/440e0051-e1a6-4fc1-b7a8-96dc6ee9928e/8617a0cf-4450-4ab1-878d-364412f5a8bb/Untitled.png)
        
        [https://velog.io/@seorim0801/은행원-알고리즘](https://velog.io/@seorim0801/%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
        
    - 자원을 요청받으면 그 자원을 할당해 주고 난 후의 상태를 여러 데이터를 이용하여 계산해서 그것이 안전상태인지를 확인한 후 안전상태가 보장되는 경우에만 할당
6. 각 유형의 단위자원이 하나밖에 없는 경우
    - 변형된 자원할당 그래프 이용
    - 그래프의 사이클 탐지를 통해 시스템이 안전상태인지를 조사(사이클 탐지는 n²의 연산으로 가능)

### 5.3.3 탐지 및 복구

1. 탐지 및 복구
    - 탐지 : 시스템의 상태를 조사하는 알고리즘을 주기적으로 수행하여 교착상태가 발생하였는지 여부를 조사
    - 복구 : 교착상태가 발생했다면 시스템은 이 교착상태로부터 복구할 수 있는 조치를 함
2. 탐지
    - Shoshani와 Coffman의 알고리즘
    - 탐지 시점 : 즉시 받아들일 수 없는 자원할당 요구가 있을 때, 혹은 정해진 시간간격 또는 CPU 효율이 일정 수준 이하로 떨어질 때
3. 복구
    - 환형 대기를 없애기 위해 교착상태 프로세스 전부 혹은 몇개를 중지
    - 교착상태에 있는 프로세스들로부터 몇개의 자원을 회수
    - 희생자 선택에 대한 선점 기준 수립 필요

### 5.3.4 복합적 접근 방법

1. 복합적 접근 방법
    - 내부자원 : 교착상태 방지
    - 메모리 : 선점을 통한 교착상태 방지
    - 작업용 자원 : 교착상태 회피
    - 교체 가능 공간 : 사전할당
