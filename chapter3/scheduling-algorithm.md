## 3.1 스케줄링 성능 평가 기준

1. 평균 대기시간
    - 각 프로세스들이 수행이 완료될 때까지 준비 큐에서 기다리는 시간의 합들의 평균값.
2. 평균 반환시간
    - 각 프로세스들이 생성된 시점부터 수행이 완료된 시점까지의 소요시간들의 평균값.

# 3.2 FCFS(First Come First Serve) 스케줄링

1. 특징
    - 비선점 스케줄링 알고리즘
    - 준비 큐에 도착한 순서에 따라 디스패치.
2. 장점
    - 가장 간단한 스케줄링 기법ㅂ임.
3. 단점
    - 짧은 프로세스가 긴 프로세스를 기다리거나, 중요한 프로세스가 나중에 수행될 수 있음(대화식 운영체제에서는 부적합)

# 3.3 SJF(Shortest Job First) 스케줄링

1. 특징
    - 비선점 스케줄링 알고리즘
    - 준비 큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상된 것을 먼저 디스패치.
2. 장점
    - 일괄처리 환경에서 구현하기 쉬움
3. 단점
    - 실행 예정 시간 길이를 사용자의 추정치에 의존하기 때문에 실제로는 먼저 처리할 작업의 CPU 시간을 예상할 수가 없음(대화식 운영체제에서는 부적합).

# 3.4 SRT(Shortest Remain Time) 스케줄링

1. 특징
    - 선점 스케줄링 알고리즘
    - 준비 큐에서 기다리는 프로세스 중 실행이 끝날 때까지 남은 시간이 가장 짧다고 예상된 것을 먼저 디스패치
2. 장점
    - SJF보다 평균 대기시간이나 평균 반환시간에서 효율적
    - 시분할 시스템에 유용
3. 단점
    - 각 프로세스의 실행시간 추적, 선점을 위한 문맥 교환 등 SJF보다 오버헤드가 큼.

## 3.5 RR(Round Robin) 스케줄링

1. 특징
    - 선점 스케줄링 알고리즘
    - 준비 큐에 도착한 순서에 따라 디스패치하지만 정해진 시간 할당되어 실행을 제한함.
    - 시간 할당량 안에 완료되지 못한 프로세스는 준비 큐의 맨 뒤에 배치함.
    - 시간 할당량에 따라 성능 변화
2. 장점
    - CPU를 독점하지 않고 공평하게 이용
    - 대화형 시스템에서 사용
3. 단점
    - 시간 할당량이 너무 크면 FCFS 정도로 성능이 낮아짐.
    - 시간 할당량이 너무 작으면 문맥 교환에 따른 오버헤드가 크게 증가함.

## 3.6 HRN 스케줄링

1. 특징
    - 비선점 스케줄링 알고리즘
    - 준비 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치함.
    - 응답비율 = 대기시간 + 예상시간 / 예상실행시간 (=대기시간/예상실행시간 +1)
    - 예상 실행시간이 짧을 수록, 그리고 대기시간이 길수록 응답비율이 커짐
2. 장점
    - SJF의 단점(긴 작업과 짧은 작업 사이의 지나친 불평등)을 보완.

## 3.7 다단계 피드백 큐 스케줄링

1. 특징
    - 선점 스케줄링 알고리즘
    - 입출력 중심인 프로세스와 CPU 중심인 프로세스의 특성에 따라 서로 다른 시간 할당량을 부여.
    - 단계 1부터 단계 n까지 각 단계마다 1개씩의 큐가 존재
    - 단계가 커질수록 시간 할당량도 커짐.
2. 스케줄링 방법
    - 신규 프로세스는 단계 1의 큐에서 FIFO 순서에 따라 CPU 점유
    - 입출력 같은 이벤트가 발생하면 CPU를 양보하고 대기상태로 갔다가 다시 준비상태가 될 때에는 현재와 동일한 단계의 큐에 배치
    - 시간 할당량을 다 썼지만 프로세스가 종료되지 못했다면 다음 단계의 큐로 이동 배치
    - 마지막 단계 n에서는 RR 스케줄링 방식으로 동작
    - 단계 k의 큐에 있는 프로세스가 CPU를 할당 받으려면 단게 1부터 단계 k-1까지 모든 큐가 비어 있어야만 함.
3. 장점
    - 입출력 위주의 프로세스(대화형)는 높은 우선권 유지
    - 연산 위주의 CPU 중심 프로세스는 낮은 우선권이지만 긴 시간 할당량 가짐
